From c789d6ef3ea6f90ce2fb0e1b0f8f7a8586b23854 Mon Sep 17 00:00:00 2001
From: Jake Merdich <Jake.Merdich@amd.com>
Date: Mon, 25 Jan 2021 13:35:00 -0500
Subject: [PATCH] Don't assume the CPUID intrinsic exists

The cpuid instruction only exists on x86/x64. Put ifdefs around those depending on platform.
Non-x86 platforms either lack a cpuid instruction or it's privileged and useless to us.

Also sanity-checks the /proc/cpuinfo code for more fallbacks to avoid a div-by-0.
---
 inc/util/palSysUtil.h       |  5 +++++
 src/util/lnx/lnxSysUtil.cpp | 27 +++++++++++++++++++++------
 src/util/sysUtil.cpp        |  8 ++++++++
 3 files changed, 34 insertions(+), 6 deletions(-)

diff --git a/inc/util/palSysUtil.h b/inc/util/palSysUtil.h
index 3c43d1c3..fd1b3021 100644
--- a/inc/util/palSysUtil.h
+++ b/inc/util/palSysUtil.h
@@ -35,8 +35,11 @@
 #include <atomic>
 
 #if   defined(__unix__)
+#define PAL_HAS_CPUID (__i386__ || __x86_64__)
+#if PAL_HAS_CPUID
 #include <cpuid.h>
 #endif
+#endif
 
 namespace Util
 {
@@ -454,6 +457,7 @@ PAL_INLINE bool IsComboKey(KeyCode key, KeyCode* pKeys)
     return ret;
 }
 
+#if PAL_HAS_CPUID
 /// Issue the cpuid instruction.
 ///
 /// @param [out]  pRegValues  EAX/EBX/ECX/EDX values
@@ -485,6 +489,7 @@ PAL_INLINE void CpuId(
 #error "Not implemented for the current platform"
 #endif
 }
+#endif // PAL_HAS_CPUID
 
 /// Play beep sound. Currently function implemented only for WIN platform.
 ///
diff --git a/src/util/lnx/lnxSysUtil.cpp b/src/util/lnx/lnxSysUtil.cpp
index 986c16df..68f72653 100644
--- a/src/util/lnx/lnxSysUtil.cpp
+++ b/src/util/lnx/lnxSysUtil.cpp
@@ -172,6 +172,7 @@ constexpr KeyCode KeyLookupTable[] =
 static_assert(KeyLookupTable[KEY_BACKSLASH] == KeyCode::Backslash, "Wrong KeyLookupTable");
 static_assert(KeyLookupTable[KEY_DELETE]    == KeyCode::Delete,    "Wrong KeyLookupTable");
 
+#if PAL_HAS_CPUID
 // =====================================================================================================================
 // Get affinity mask of each core complex for AMD processor
 static Result GetCcxMask(
@@ -215,6 +216,7 @@ static Result GetCcxMask(
 
     return Result::Success;
 }
+#endif
 
 // =====================================================================================================================
 // Queries system information.
@@ -225,6 +227,9 @@ Result QuerySystemInfo(
 
     if (pSystemInfo != nullptr)
     {
+        // Null-terminate the string. The returned vendor string is always 12 bytes and does not include a terminator.
+        pSystemInfo->cpuVendorString[12] = '\0';
+#if PAL_HAS_CPUID
         uint32 regValues[4] = {};
 
         // Query the vendor string
@@ -234,9 +239,6 @@ Result QuerySystemInfo(
         *reinterpret_cast<uint32*>(&pSystemInfo->cpuVendorString[4]) = regValues[3]; // EDX
         *reinterpret_cast<uint32*>(&pSystemInfo->cpuVendorString[8]) = regValues[2]; // ECX
 
-        // Null-terminate the string. The returned vendor string is always 12 bytes and does not include a terminator.
-        pSystemInfo->cpuVendorString[12] = '\0';
-
         // CPUID instruction constants
         constexpr uint32 BrandStringFunctionId      = 0x80000000;
         constexpr uint32 BrandStringFunctionIdBegin = 0x80000002;
@@ -279,10 +281,12 @@ Result QuerySystemInfo(
                 pSystemInfo->cpuType = CpuType::Unknown;
             }
         }
+#endif
 
         pSystemInfo->cpuLogicalCoreCount  = 0;
         pSystemInfo->cpuPhysicalCoreCount = 0;
         pSystemInfo->cpuFrequency = 0;
+        uint32 cpuClockSpeedTotal = 0;
 
         // parse /proc/cpuinfo to get logical and physical core info
         File cpuInfoFile;
@@ -302,7 +306,6 @@ Result QuerySystemInfo(
             CpuCoreCount*        pCoreCount         = nullptr;
             bool                 coreCountPopulated = false;
             GenericAllocatorAuto allocator;
-            uint32               cpuClockSpeedTotal = 0;
 
             auto pBuf = static_cast<char* const>(PAL_CALLOC(BufSize, &allocator, AllocInternalTemp));
             PhysicalPackageCoreCountMap coreCountPerPhysicalId(MaxSocketsHint, &allocator);
@@ -389,22 +392,34 @@ Result QuerySystemInfo(
                     pSystemInfo->cpuLogicalCoreCount  += coreCount.logicalCoreCount;
                     pSystemInfo->cpuPhysicalCoreCount += coreCount.physicalCoreCount;
                 }
-                pSystemInfo->cpuFrequency = cpuClockSpeedTotal / pSystemInfo->cpuLogicalCoreCount;
             }
         }
 
         cpuInfoFile.Close();
-
+#if PAL_HAS_CPUID
         // GetCcxMask() should be called only for Ryzen for now.
         if ((result == Result::Success) && (pSystemInfo->cpuType == CpuType::AmdRyzen))
         {
             result = GetCcxMask(pSystemInfo, pSystemInfo->cpuLogicalCoreCount);
         }
+#endif
 
         if (result == Result::Success)
         {
              uint64 totalMemByteSize = sysconf( _SC_PHYS_PAGES ) * sysconf( _SC_PAGESIZE );
              pSystemInfo->totalSysMemSize = static_cast<uint32>(totalMemByteSize / 1024 / 1024);
+
+             // /proc/cpuinfo varies by arch, so we might have got no data at all.
+             // Have a robust but less-detailed fallback
+             if (pSystemInfo->cpuPhysicalCoreCount == 0)
+             {
+                 pSystemInfo->cpuPhysicalCoreCount = sysconf(_SC_NPROCESSORS_ONLN);
+             }
+             if (pSystemInfo->cpuLogicalCoreCount == 0)
+             {
+                 pSystemInfo->cpuLogicalCoreCount = pSystemInfo->cpuPhysicalCoreCount;
+             }
+             pSystemInfo->cpuFrequency = cpuClockSpeedTotal / pSystemInfo->cpuLogicalCoreCount;
         }
     }
 
diff --git a/src/util/sysUtil.cpp b/src/util/sysUtil.cpp
index 51f6d473..87ae0715 100644
--- a/src/util/sysUtil.cpp
+++ b/src/util/sysUtil.cpp
@@ -61,6 +61,7 @@ static constexpr uint32 IntelPentium4Family          = 0xF;           ///< Penti
 void QueryAMDCpuType(
     SystemInfo* pSystemInfo)
 {
+#if PAL_HAS_CPUID
     uint32 reg[4] = {};
 
     CpuId(reg, 1);
@@ -137,6 +138,9 @@ void QueryAMDCpuType(
             pSystemInfo->cpuType = CpuType::Unknown;
             break;
     }
+#else
+    pSystemInfo->cpuType = CpuType::Unknown;
+#endif
 }
 
 // =====================================================================================================================
@@ -144,6 +148,7 @@ void QueryAMDCpuType(
 void QueryIntelCpuType(
     SystemInfo* pSystemInfo)
 {
+#if PAL_HAS_CPUID
     uint32 reg[4] = {};
 
     CpuId(reg, 1);
@@ -206,6 +211,9 @@ void QueryIntelCpuType(
             pSystemInfo->cpuType = CpuType::Unknown;
             break;
     }
+#else
+    pSystemInfo->cpuType = CpuType::Unknown;
+#endif
 }
 
 } // Util
